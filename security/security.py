import random
from jose import jws as jose_jws
from jwcrypto import jwa as jw_jwa
from jwcrypto import jwe as jw_jwe
from jwcrypto import jwk as jw_jwk
from jwcrypto import jws as jw_jws
from jwcrypto import jwt as jw_jwt
from jwcrypto.common import base64url_decode, base64url_encode
from jwcrypto.common import json_decode, json_encode
from Crypto.PublicKey import RSA 
from Crypto.Signature import PKCS1_v1_5 
from Crypto.Hash import SHA256 
from base64 import b64encode, b64decode 
from pprint import pprint as pp
try:
    import urllib.parse as url_parser
except:
    import urllib as url_parser
import urllib
import json
import time

def generate_nonce(length=8):
    """Generate pseudorandom number."""
    return ''.join([str(random.randint(0, 9)) for i in range(length)])

def generate_timestamp():
    """Get seconds since epoch (UTC)."""
    #return int(time.time())
    millis = int(round(time.time() * 1000))
    return millis

# Verify & Decode JWS or JWT
def verifyJWS(token, publicCert):
    pemfile = open(publicCert, 'r')
    keystring = pemfile.read()
    pemfile.close()
    payload = jose_jws.verify(token, keystring,  algorithms=['RS256'])
    pp(payload)
    payload = json.loads(payload.decode('utf8'))
    pp(payload)
    return payload

def _merge_(dict1, dict2): 
    return (dict1.update(dict2)) 

def _generateSHA256withRSAHeader_(url, params, method, strContentType, appId, keyCertContent, keyCertPassphrase, realm):
    nonceValue = generate_nonce(15)
    timestamp = generate_timestamp()
    pp(nonceValue)
    pp(timestamp)

    # A) Construct the Authorisation Token
    defaultApexHeaders = {
                            "apex_l2_eg_app_id": appId,
                            "apex_l2_eg_nonce": nonceValue,
                            "apex_l2_eg_signature_method": "SHA256withRSA",
                            "apex_l2_eg_timestamp": timestamp,
                            "apex_l2_eg_version": "1.0"
                         }
    # Remove params unless Content-Type is "application/x-www-form-urlencoded"
    if (method == "POST" and strContentType != "application/x-www-form-urlencoded"):
        params = {}
    pp(params)

    # B) Forming the Signature Base String

    # i) Normalize request parameters
    baseParams = _merge_(defaultApexHeaders, params)
    baseParams = defaultApexHeaders
    pp(baseParams)
    baseParams = {k: baseParams[k] for k in sorted(baseParams)}
    pp(baseParams)

    # baseParamsStr = json.dumps(baseParams)
    baseParamsStr = url_parser.urlencode(baseParams)
    pp("baseParamsStr11" +"=" + baseParamsStr)
    #baseParamsStr = baseParamsStr.encode().decode('unicode_escape')
    baseParamsStr = url_parser.unquote(baseParamsStr)
    pp("baseParamsStr22" +"=" + baseParamsStr)

    # ii) construct request URL ---> url is passed in to this function

    # iii) concatenate request elements
    baseString = method.upper() + "&" + url + "&" + baseParamsStr

    pp("Formulated Base String")
    pp("Base String generated by your application that will be signed using your private key.")
    pp(baseString)

    # C) Signing Base String to get Digital Signature
    with open(keyCertContent, "rb") as pemfile:  
        data = pemfile.read() 
    pp(data)
    rsakey = RSA.importKey(data, keyCertPassphrase)
    # Load pem file containing the x509 cert & private key & sign the base string with it.
    signer = PKCS1_v1_5.new(rsakey) 
    digest = SHA256.new()
        
    # It's being assumed the data is base64 encoded, so it's decoded before updating the digest 
    digest = SHA256.new(baseString.encode()) 
    signature = signer.sign(digest) 

    pp("Digital Signature:")
    pp("Signature produced by signing the above Base String with your private key.")
    pp(b64encode(signature))
    pp(keyCertContent)


    # D) Assembling the Header
    strApexHeader = ("Apex_l2_eg realm=\"" + realm + "\",apex_l2_eg_timestamp=\"" + str(timestamp) +
        "\",apex_l2_eg_nonce=\"" + nonceValue + "\",apex_l2_eg_app_id=\"" + appId +
        "\",apex_l2_eg_signature_method=\"SHA256withRSA\",apex_l2_eg_version=\"1.0\",apex_l2_eg_signature=\"" + b64encode(signature).decode() +
        "\"")
    pp(strApexHeader)
    #pubkey_content = None
    #with open("./ssl/publickey.pem", "rb") as pubfile:  
    #    pubkey_content = pubfile.read().decode('utf-8')
    #    pp(pubkey_content)
    #    pubkey = RSA.importKey(pubkey_content) 
    #    signer = PKCS1_v1_5.new(pubkey) 
    #    digest = SHA256.new() 
    #    # Assumes the data is base64 encoded to begin with
    #    baseString = baseString 
    #    pp(baseString)
    #    pp(b64encode(baseString.encode()))
    #    digest.update(b64encode(baseString.encode()))
        
    #
    #    pp(b64encode(signature).decode('utf-8'))
    #    if signer.verify(digest, signature):
    #        pp("verify ok")
    #    else:
    #        pp("verify not ok")
    return strApexHeader

def generateAuthorizationHeader(url, params, method, strContentType, authType, appId, keyCertContent, passphrase, realm):
    # need to include the ".e." in order for the security authorisation header to work
    url_ = url.replace(".api.gov.sg", ".e.api.gov.sg")
    pp(url)
    if authType == "L2":
        return _generateSHA256withRSAHeader_(url_, params, method, strContentType, appId, keyCertContent, passphrase, realm)
    else:
        return ""

def decryptJWE(raw_jwe, privateKey):
    with open(privateKey, "rb") as pemfile:  
        key_content = pemfile.read()
    prik = jw_jwt.JWK.from_pem(key_content)
    e = jw_jwe.JWE()
    e.deserialize(raw_jwe, prik)
    return json.loads(e.payload.decode('utf-8'))

if __name__ == "__main__":
    keycertpath = "./ssl/stg-demoapp-client-privatekey-2018.pem"
    pubkeypath = "./ssl/stg-demoapp-client-publiccert-2018.pem"
    public = "./ssl/stg-auth-signing-public.pem"
    certkey = "44d953c796cccebcec9bdc826852857ab412fbe2"
    params = {"attributes" : "age,sex,name"}
    method = "GET"
    strContentType = ""
    appId = "1"
    realm = "localhost:3001/callback"
    url = "https://www.api.gov.sg"
    authType = "L2"
    r = generateAuthorizationHeader(url, params, method, strContentType, authType, appId, keycertpath, certkey, realm)

